# MySQL

MySQL的优化

mysql8.0及之后移除了缓存

 ![img](https://user-gold-cdn.xitu.io/2020/6/11/172a1288c30421ba?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

因为在MySQL8.0之前我们的数据库是存在缓存这样的情况的，我之前就被坑过，因为存在缓存，我发现我sql怎么执行都是很快，当然第一次其实不快但是我没注意到，以至于上线后因为缓存经常失效，导致rt（Response time）时高时低。

后面就发现了是缓存的问题，我们在执行SQL的时候，记得加上SQL NoCache去跑SQL，这样跑出来的时间就是真实的查询时间了。

**缓存失效**

如果我们当前的MySQL版本支持缓存而且我们又开启了缓存，那每次请求的查询语句和结果都会以key-value的形式缓存在内存中的，一个请求会先去看缓存是否存在，不存在才会走解析器。

缓存失效比较频繁的原因就是，只要一**对表进行更新**，那这个表**所有的缓存都会被清空**，其实我们很少存在不更新的表，。

大家如果是8.0以上的版本就不用担心这个问题，如果是8.0之下的版本，记得排除缓存的干扰。

## 1.Mysql索引

### 1.1概述

是存储引擎用于快速找到记录的一种数据结构. 

### 1.2 索引的优点

索引有哪些**优点**呢?

- 减少查询需要扫描的数据量(加快了查询速度)
- 减少服务器的排序操作和创建临时表的操作(加快了groupby和orderby等操作)
- 将服务器的随机IO变为顺序IO(加快查询速度).

索引有哪些**缺点**呢?

1. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。

### **1.3索引分类**( 主键就是聚簇索引 )

InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。 

 如果表(InnoDB)设置了主键，则主键就是聚簇索引 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引 

MySQL主要有以下几种索引:

- B-树索引/B+树索引
- 哈希索引
- 空间数据索引
- 全文索引



#### 1.3.1 B+树

![img](https://upload-images.jianshu.io/upload_images/3575048-b5309bfe660a8ce9.png?imageMogr2/auto-orient/strip|imageView2/2/w/543/format/webp)

B+树是B-树的进阶版本,在B-树的基础上又做了如下的限制:

1. 每个中间节点不保存数据,只用来索引,也就意味着所有非叶子节点的值都被保存了一份在叶子节点中.
2. 叶子节点之间根据自身的顺序进行了链接.

这样可以带来什么好处呢?

1. 中间节点不保存数据,那么就可以保存更多的索引,减少数据库磁盘IO的次数.
2. 因为中间节点不保存数据,所以每一次的查找都会命中到叶子节点,而叶子节点是处在同一层的,因此查询的性能更加的稳定.
3. 所有的叶子节点按顺序链接成了链表,因此可以方便的话进行范围查询.

#### 1.3.2hash索引

![img](https://img-blog.csdn.net/20170104204929966)

  Hash 索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位 

  1).Hash 索引仅仅能满足"=","IN"和"<=>"查询，不能使用范围查询。 (**只能用于等值判断**)

  2).Hash 索引**无法**被用来避免数据的**排序**操作。
    由于 Hash 索引中存放的是经过 Hash 计算之后的 Hash 值，而且Hash值的大小关系并不一定和 Hash 运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算；
  3).Hash 索引**不能利用部分索引**键查询。
    对于组合索引，Hash 索引在计算 Hash 值的时候是组合索引键合并后再一起计算 Hash 值，而不是单独计算 Hash 值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash 索引也无法被利用。
  4).Hash 索引在任何时候都不能避免**表扫描**。
    前面已经知道，Hash 索引是将索引键通过 Hash 运算之后，将 Hash运算结果的 Hash 值和所对应的行指针信息存放于一个 Hash 表中，由于不同索引键存在相同 Hash 值，所以即使取满足某个 Hash 键值的数据的记录条数，也无法从 Hash 索引中直接完成查询，还是要通过访问表中的实际数据进行相应的比较，并得到相应的结果。
  5).Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。



#### **1.3.3 B+树索引和哈希索引的区别**

 1).如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；
​    2).从示意图中也能看到，如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；
​    3).同理，哈希索引也没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；
​    4).哈希索引也不支持多列联合索引的最左匹配规则；
​    5).B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。

#### 1.3.4 B+树和B树的区别(索引)

1、B+**树的层级更少**：相较于B树B+每个**非叶子**节点存储的关键字数更多，树的层级更少所以查询数据更快；

2、B+**树查询速度更稳定**：B+所有关键字数据地址都存在**叶子**节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;

3、B+**树天然具备排序功能：**B+树所有的**叶子**节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。

4、B+**树全节点遍历更快：**B+树遍历整棵树只需要遍历所有的**叶子**节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。

**B树**相对于**B+树**的优点是，如果经常访问的数据离根节点很近，而**B树**的**非叶子**节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比**B+树**快。

### 1.4聚簇索引 & 非聚簇索引

**InnoDB** 主键使用的是**聚簇索引**，**MyISAM** 不管是主键索引，还是二级索引使用的都是**非聚簇索引**。 

 如果表(InnoDB)设置了主键，则**主键就是聚簇索引**, 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引 

 聚集索引与非聚集索引的**区别**是：叶节点是否存放一整行记录 

 下图形象说明了聚簇索引表(InnoDB)和非聚簇索引(MyISAM)的区别： ![img](https://user-gold-cdn.xitu.io/2019/5/16/16ac10253b8748df?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)1.对于**非聚簇索引表**来说（右图），**表数据和索引是分成两部分存储的**，主键索引和二级索引存储上没有任何区别。使用的是B+树作为索引的存储结构，所有的节点都是索引，叶子节点存储的是索引+索引对应的记录的数据。

2.对于**聚簇索引表**来说（左图），表**数据是和主键一起存储的**，主键索引的叶结点存储行数据(包含了主键值)，二级索引的叶结点存储行的主键值。使用的是B+树作为索引的存储结构，非叶子节点都是索引关键字，但非叶子节点中的关键字中不存储对应记录的具体内容或内容地址。叶子节点上的数据是主键与具体记录(数据内容)。

**聚簇索引的优点**

1.当你需要取出一定范围内的数据时，用聚簇索引也比用非聚簇索引好。

2.当通过聚簇索引查找目标数据时理论上比非聚簇索引要快，因为非聚簇索引定位到对应主键时还要多一次目标记录寻址,即多一次I/O。

3.使用覆盖索引扫描的查询可以直接使用页节点中的主键值。

**聚簇索引的缺点**

1.**插入速度严重依赖于插入顺序**，按照主键的顺序插入是最快的方式，否则将会出现页分裂，严重影响性能。因此，对于InnoDB表，我们一般都会定义一个**自增的ID列为主键**。

2.**更新主键的代价很高，因为将会导致被更新的行移动**。因此，对于InnoDB表，我们一般定义主键为不可更新。

3.**二级索引访问需要两次索引查找，第一次找到主键值，第二次根据主键值找到行数据。**

二级索引的叶节点存储的是主键值，而不是行指针（非聚簇索引存储的是指针或者说是地址），这是为了减少当出现行移动或数据页分裂时二级索引的维护工作，但会让二级索引占用更多的空间。

4.**采用聚簇索引插入新值比采用非聚簇索引插入新值的速度要慢很多**，因为插入要保证主键不能重复，判断主键不能重复，采用的方式在不同的索引下面会有很大的性能差距，聚簇索引遍历所有的叶子节点，非聚簇索引也判断所有的叶子节点，但是聚簇索引的叶子节点除了带有主键还有记录值，记录的大小往往比主键要大的多。这样就会导致聚簇索引在判定新记录携带的主键是否重复时进行昂贵的I/O代价。

**非聚簇索引**

 非聚簇索引，又叫二级索引。二级索引的叶子节点中保存的不是指向行的物理指针，而是行的主键值。当通过二级索引查找行，存储引擎需要在二级索引中找到相应的叶子节点，获得行的主键值，然后使用**主键去聚簇索引中查找数据行**，这需要两次B-Tree查找。

 ![Innodb聚簇索引和非聚簇索引](https://nullcc.github.io/assets/images/post_imgs/mysql_index_3.png)



### 1.5MySQL索引的类型

**1. 普通索引**

这是最基本的索引，它**没有任何限制**，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。



```sql
01  –直接创建索引
02  CREATE INDEX index_name ON table(column(length))

03  –修改表结构的方式添加索引
04  ALTER TABLE table_name ADD INDEX index_name ON (column(length))

05  –创建表的时候同时创建索引
06  CREATE TABLE `table` (
07      `id` int(11) NOT NULL AUTO_INCREMENT ,
08      `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
09      `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
10      `time` int(10) NULL DEFAULT NULL ,
11       PRIMARY KEY (`id`),
12       INDEX index_name (title(length))
13  )

14  –删除索引
15  DROP INDEX index_name ON table
```

**2. 唯一索引**

与普通索引类似，不同的就是：**索引列的值必须唯一**，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。



```sql
01  –创建唯一索引
02  CREATE UNIQUE INDEX indexName ON table(column(length))

01 -添加PRIMARY KEY（主键索引）
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 

03  –修改表结构
04  ALTER TABLE table_name ADD UNIQUE indexName ON (column(length))

05  –创建表的时候直接指定
06  CREATE TABLE `table` (
07      `id` int(11) NOT NULL AUTO_INCREMENT ,
08      `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
09      `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
10      `time` int(10) NULL DEFAULT NULL ,
11      PRIMARY KEY (`id`),
12      UNIQUE indexName (title(length))
13  );
```

**3. 全文索引**

MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引(全文索引)**仅可用于 MyISAM** 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。////对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。



```sql
01  –创建表的适合添加全文索引
02  CREATE TABLE `table` (
03    `id` int(11) NOT NULL AUTO_INCREMENT ,
04    `title` char(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL ,
05    `content` text CHARACTER SET utf8 COLLATE utf8_general_ci NULL ,
06    `time` int(10) NULL DEFAULT NULL ,
07    PRIMARY KEY (`id`),
08    FULLTEXT (content)
09  );

10  –修改表结构添加全文索引
11  ALTER TABLE article ADD FULLTEXT index_content(content)

12  –直接创建索引
13  CREATE FULLTEXT INDEX index_content ON article(content)
```

**4. 单列索引、多列索引**

多个单列索引与单个多列索引的查询效果不同，因为执行查询时，MySQL只能使用一个索引，会从多个索引中选择一个限制最为严格的索引。

**5. 组合索引**

平时用的SQL查询语句一般都有比较多的限制条件，所以为了进一步榨取MySQL的效率，就要考虑建立组合索引。例如上表中针对title和time建立一个组合索引：

~~~sql
ALTER TABLE `table_name` ADD INDEX index_name ( `col1`, `col2`, `col3` )
~~~

建立这样的组合索引，其实是相当于分别建立了下面组组合索引：

 **如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如, 如果你创建了一个三列的联合索引包含(col1, col2, col3), 你的索引会生效于(col1), (col1, col2), 以及(col1, col2, col3)**  类似与闯关,只有过了第一关才有后面的  

**注:MySQL会优化查询的顺序**

### **1.6索引失效**

1. or 语句，如果要在or语句中使用索引，那么所有条件都必须使用索引，建议尽量少用or语句

2. like 前缀，类似语句  like %aa

3. 使用索引效率比不使用更低，比如TYPE

4. 索引不存空值，所以  is null 条件语句不使用

5. 多列索引，有预判，其他索引列失效

6. 对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。需要注意的是，优化器并不是要放弃使用这个索引。这个时候大家可以用一些取巧的方法，比如 select * from tradelog where id + 1 = 10000 就走不上索引，select * from tradelog where id = 9999就可以。

7. 隐式类型转换

   select * from t where id = 1如果id是字符类型的，1是数字类型的，你用explain会发现走了全表扫描，根本用不上索引，为啥呢？因为MySQL底层会对你的比较进行转换，相当于加了 CAST( id AS signed int) 这样的一个函数，上面说过函数会导致走不上索引

8. 隐式字符编码转换

   还是一样的问题，如果两个表的字符集不一样，一个是utf8mb4，一个是utf8，因为utf8mb4是utf8的超集，所以一旦两个字符比较，就会转换为utf8mb4再比较。转换的过程相当于加了CONVERT(id USING utf8mb4)函数，那又回到上面的问题了，用到函数就用不上索引了。还有大家一会可能会遇到mysql突然卡顿的情况，那可能是MySQLflush了

  ### 1.7使用索引的注意事项

  1. 在经常需要搜索的列上，可以加快搜索的速度；

  2. 在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。

  3. 在经常需要排序的列上创 建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；

  4. 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引

  5. 在经常用在连接的列上，这 些列主要是一些外键，可以加快连接的速度；

  6. 避免 where 子句中对宇段施加函数，这会造成无法命中索引。

  7. 在使用InnoDB时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。

  8. ~~将打算加索引的列设置为 NOT NULL ，否则将导致引擎放弃使用索引而进行全表扫描。~~

     订正，来自[issue758](https://github.com/Snailclimb/JavaGuide/issues/758) 。**将某一列设置为default null，where 是可以走索引，另外索引列是否设置 null 是不影响性能的。** 但是，还是不建议列上允许为空。最好限制not null，因为null需要更多的存储空间并且null值无法参与某些运算。

     《高性能MySQL》第四章如是说：And, in case you’re wondering, allowing NULL values in the index really doesn’t impact performance 。NULL 值的索引查找流程参考：https://juejin.im/post/5d5defc2518825591523a1db ,相关阅读：[MySQL中IS NULL、IS NOT NULL、!=不能用索引？胡扯！](https://juejin.im/post/5d5defc2518825591523a1db) 。

  9. 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 chema_unused_indexes 视图来查询哪些索引从未被使用

  10. 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

  ### 1.8覆盖索引

InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引。

 如果表(InnoDB)设置了主键，则**主键就是聚簇索引** 如果表没有主键，则会默认第一个NOT NULL，且唯一（UNIQUE）的列作为聚簇索引 以上都没有，则会默认创建一个隐藏的row_id作为聚簇索引    (  因为数据行不能存在两个地方，所以**一个表只能有一个聚簇索引**。  )

**什么是覆盖索引**

  如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道InnoDB存储引擎中，如果不是**主键索引**，**叶子节点存储的是主键+列值**( 再使用主键去聚簇索引中查找数据行，这需要两次B-Tree查找。 )。最终还是要“**回表**”，也就是要通过主键再查找一次。这样就会比较慢.覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！

**覆盖索引使用实例**

eg

~~~sql
CREATE TABLE `student` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '自增主键',
  `name` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '名称',
  `age` int(3) unsigned NOT NULL DEFAULT '1' COMMENT '年龄',
  PRIMARY KEY (`id`),
  KEY `I_name` (`name`)
) ENGINE=InnoDB;

INSERT INTO student (name, age) VALUES("小赵", 10),("小王", 11),("小李", 12),("小陈", 13);
~~~

主键自增

 ![img](https://user-gold-cdn.xitu.io/2019/10/15/16dcff55c1ff558f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 



 ![img](https://user-gold-cdn.xitu.io/2019/10/15/16dd012fccb51ee0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

```sql
SELECT age FROM student WHERE name = '小李'；
```

流程为：

1. 在name索引树上找到名称为小李的节点 id为03
2. 从id索引树上找到id为03的节点 获取所有数据
3. 从数据中获取字段命为age的值返回 12

 **在流程中从非主键索引树搜索回到主键索引树搜索的过程称为：回表**，在本次查询中因为查询结果只存在主键索引树中，我们必须回表才能查询到结果，那么如何优化这个过程呢？引入正文覆盖索引 



~~~sql
ALTER TABLE student DROP INDEX I_name;	 
ALTER TABLE student ADD INDEX I_name_age(name, age);
~~~

删除索引name

创建组合索引（name，age），我们执行下面的 sql 语句

  ```sql
SELECT age FROM student WHERE name = '小李'；
  ```

 ![img](https://user-gold-cdn.xitu.io/2019/10/16/16dd033b2a2c7c24?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

  在查询数据的时候：要查询出的列在叶子节点都存在！所以，就不用回表（或者使用的聚簇索引）。



当发起一个索引覆盖查询时，在explain的extra列可以看到using index的信息

![img](https://user-gold-cdn.xitu.io/2019/10/16/16dd03e788c92e7e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这里我们很清楚的看到Extra中Using index表明我们成功使用了覆盖索引



> 总结：覆盖索引避免了回表现象的产生，从而减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是性能优化的一种手段，文章有不当之处，欢迎指正~

**选择索引和编写利用这些索引的查询的3个原则**

1. 单行访问是很慢的。特别是在机械硬盘存储中(SSD的随机I/O要快很多，不过这一点仍然成立）。如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中能包含尽可能多所需要的行。使用索引可以创建位置引，用以提升效率。
2. 按顺序访问范围数据是很快的，这有两个原因。第一，顺序1/0不需要多次磁盘寻道，所以比随机I/O要快很多（特别是对机械硬盘）。第二，如果服务器能够按需要顺序读取数据，那么就不再需要额外的排序操作，并且GROUPBY查询也无须再做排序和将行按组进行聚合计算了。
3. 索引覆盖查询是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就 不需要再回表查找行。这避免了大量的单行访问，而上面的第1点已经写明单行访 问是很慢的。

  ### 1.9为什么索引能提高查询速度(原理)

  > 以下内容整理自： 地址： https://juejin.im/post/5b55b842f265da0f9e589e79 作者 ：Java3y

先从 MySQL 的基本存储结构说起

  MySQL的基本存储结构是页(记录都存在页里边)：

  [![MySQL的基本存储结构是页](https://camo.githubusercontent.com/57a746bf254e100c3fd0d2691d172df5c29592eb/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f32383535393432312e6a7067)](https://camo.githubusercontent.com/57a746bf254e100c3fd0d2691d172df5c29592eb/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f32383535393432312e6a7067)

  [![img](https://camo.githubusercontent.com/a0e0c5b1377f6ab52365479c52313f4238550d31/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f38323035333133342e6a7067)](https://camo.githubusercontent.com/a0e0c5b1377f6ab52365479c52313f4238550d31/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f38323035333133342e6a7067)

  - **各个数据页可以组成一个双向链表**

- 每个数据页中的记录又可以组成一个单向链表

  - 每个数据页都会为存储在它里边儿的记录生成一个页目录，在通过主键查找某条记录的时候可以在页目录中使用二分法快速定位到对应的槽，然后再遍历该槽对应分组中的记录即可快速找到指定的记录
  - 以其他列(非主键)作为搜索条件：只能从最小记录开始依次遍历单链表中的每条记录。

  所以说，如果我们写select * from user where indexname = 'xxx'这样没有进行任何优化的sql语句，默认会这样做：

  1. **定位到记录所在的页：需要遍历双向链表，找到所在的页**

2. **从所在的页内中查找相应的记录：由于不是根据主键查询，只能遍历所在页的单链表了**

很明显，在数据量很大的情况下这样查找会很慢！这样的时间复杂度为O（n）。

使用索引之后

  索引做了些什么可以让我们查询加快速度呢？其实就是**将无序的数据变成有序**(相对)：

  [![img](https://camo.githubusercontent.com/83e4b2a638e8352a21feafeafe97cbad0fc2a335/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f353337333038322e6a7067)](https://camo.githubusercontent.com/83e4b2a638e8352a21feafeafe97cbad0fc2a335/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f353337333038322e6a7067)

  要找到id为8的记录简要步骤：

  [![img](https://camo.githubusercontent.com/c63688b141c3562bbf4fb4b719ab027c6dea91e9/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f38393333383034372e6a7067)](https://camo.githubusercontent.com/c63688b141c3562bbf4fb4b719ab027c6dea91e9/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d31302d322f38393333383034372e6a7067)

  很明显的是：没有用索引我们是需要遍历双向链表来定位对应的页，现在通过 **“目录”** 就可以很快地定位到对应的页上了！（二分查找，时间复杂度近似为O(logn)）

  其实底层结构就是B+树，B+树作为树的一种实现，能够让我们很快地查找出对应的记录。

  ### 1.10关于索引其他重要的内容补充

  > 以下内容整理自：《Java工程师修炼之道》

  #### 1.10.1最左前缀原则

  MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：

 **如果表拥有一个联合索引, 任何一个索引的最左前缀都会被优化器用于查找列. 比如, 如果你创建了一个三列的联合索引包含(col1, col2, col3), 你的索引会生效于(col1), (col1, col2), 以及(col1, col2, col3)**  类似与闯关,只有过了第一关才有后面的  

  #### 1.10.2注意避免冗余索引

  冗余索引指的是索引的功能相同，能够命中 就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

  MySQL 5.7 版本后，可以通过查询 sys 库的 `schema_redundant_indexes` 表来查看冗余索引





## 2.Mysql存储引擎

### 2.1 InnoDB存储引擎（推荐）

InnoDB(B+Tree)是事务型数据库的首选引擎，支持事务安全表（ACID），支持行锁定和外键，上图也看到了，InnoDB是默认的MySQL引擎。

> InnoDB主要特性

- 为MySQL提供了具有提交、回滚和崩溃恢复能力的事物安全（ACID兼容）存储引擎。InnoDB锁定在行级并且也在`SELECT`语句中提供一个类似Oracle的非锁定读。这些功能增加了多用户部署和性能。在SQL查询中，可以自由地将InnoDB类型的表和其他MySQL的表类型混合起来，甚至在同一个查询中也可以混合
- InnoDB存储引擎为在主内存中缓存数据和索引而维持它自己的缓冲池。InnoDB将它的表和索引在一个逻辑表空间中，表空间可以包含数个文件（或原始磁盘文件）。这与MyISAM表不同，比如在MyISAM表中每个表被存放在分离的文件中。InnoDB表可以是任何尺寸，即使在文件尺寸被限制为2GB的操作系统上
- InnoDB支持外键完整性约束，存储表中的数据时，每张表的存储都按主键顺序存放，如果没有显示在表定义时指定主键，InnoDB会为每一行生成一个6字节的ROWID，并以此作为主键

使用 **InnoDB存储引擎** MySQL将在数据目录下创建一个名为 `ibdata1 `的10MB大小的自动扩展数据文件，以及两个名为`ib_logfile0`和`ib_logfile1`的5MB大小的日志文件

#### 2.1.1 InnoDB 中的行锁与表锁

前面提到过，在 InnoDB 引擎中既支持行锁也支持表锁，那么**什么时候会锁住整张表？什么时候只锁住一行呢？**

InnoDB 行锁是通过给索引上的索引项加锁来实现的，这一点 MySQL 与 Oracle 不同，后者是通过在数据块中对相应数据行加锁来实现的。InnoDB 这种行锁实现的特点意味着：**只有通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁。**

在实际应用中，要特别注意 InnoDB 行锁的这一特性，不然的话，可能导致大量的锁冲突，从而影响并发性能。

- 在**不通过索引条件查询**的时候，**InnoDB 确实使用的是表锁**，而不是行锁。
- 由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，因此虽然是访问不同行的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。
- 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，另外，不论是使用主键索引、唯一索引还是普通索引，InnoDB 都会使用行锁来对数据加锁。
- 即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同的执行计划的代价来决定的。如果 **MySQL 认为全表扫描效率更高，比如对一些很小的表，它就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁**。因此，在分析锁冲突时，别忘了检查 SQL 的执行计划，以确认是否真正使用了索引。

#### 2.1.2行级锁与死锁

**MyISAM 中是不会产生死锁**的，因为 MyISAM 总是一次性获得所需的全部锁，要么全部满足，要么全部等待。而在 InnoDB 中，锁是逐步获得的，就造成了死锁的可能。

在 MySQL 中，**行级锁并不是直接锁记录，而是锁索引**。索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条 SQL 语句操作了非主键索引，MySQL 就会先锁定该非主键索引，再锁定相关的主键索引。 在进行`UPDATE`、`DELETE`操作时，MySQL 不仅锁定`WHERE`条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的`next-key locking`.

当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引；另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。

发生死锁后，InnoDB 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。

### 2.2MyISAM存储引擎

MyISAM(B+Tree)基于ISAM存储引擎，并对其进行扩展。它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一。MyISAM拥有较高的插入、查询速度，但不支持事物。

> MyISAM主要特性：

- 被大文件系统和操作系统支持
- 当把删除和更新及插入操作混合使用的时候，动态尺寸的行产生更少碎片。这要通过合并相邻被删除的块，若下一个块被删除，就扩展到下一块自动完成
- 每个MyISAM表最大索引数是64，这可以通过重新编译来改变。每个索引最大的列数是16
- 最大的键长度是1000字节，这也可以通过编译来改变，对于键长度超过250字节的情况，一个超过1024字节的键将被用上
- BLOB和TEXT列可以被索引
- NULL被允许在索引的列中，这个值占每个键的0~1个字节
- 所有数字键值以高字节优先被存储以允许一个更高的索引压缩
- 每个MyISAM类型的表都有一个AUTO_INCREMENT的内部列，当INSERT和UPDATE操作的时候该列被更新，同时AUTO_INCREMENT列将被刷新。所以说，MyISAM类型表的AUTO_INCREMENT列更新比InnoDB类型的AUTO_INCREMENT更快
- 可以把数据文件和索引文件放在不同目录
- 每个字符列可以有不同的字符集
- 有VARCHAR的表可以固定或动态记录长度
- VARCHAR和CHAR列可以多达64KB

使用MyISAM引擎创建数据库，将产生3个文件。文件的名字以表名字开始，扩展名之处文件类型：frm文件存储表定义、数据文件的扩展名为.MYD（MYData）、索引文件的扩展名时.MYI（MYIndex）



### 2.3MEMORY存储引擎(很少使用)

MEMORY存储引擎将表中的数据存储到内存中，未查询和引用其他表数据提供快速访问。

> MEMORY主要特性：

- MEMORY表的每个表可以有多达32个索引，每个索引16列，以及500字节的最大键长度
- MEMORY存储引擎执行HASH和BTREE缩影
- 可以在一个MEMORY表中有非唯一键值
- MEMORY表使用一个固定的记录长度格式
- MEMORY不支持BLOB或TEXT列
- MEMORY支持AUTO_INCREMENT列和对可包含NULL值的列的索引
- MEMORY表在所由客户端之间共享（就像其他任何非TEMPORARY表）
- MEMORY表内存被存储在内存中，内存是MEMORY表和服务器在查询处理时的空闲中，创建的内部表共享
- 当不再需要MEMORY表的内容时，要释放被MEMORY表使用的内存，应该执行`DELETE FROM`或`TRUNCATE TABLE`，或者删除整个表（使用DROP TABLE）

### 2.4存储引擎的选择

![存储引擎对比](https://segmentfault.com/img/remote/1460000012588610)









## 3.锁

 Mysql中事务的四大特性主要包含：**「原子性（Atomicity）」**、**「一致性（Consistent）」**、**「隔离性（Isalotion）」**、**「持久性(Durable)」** 

###  **ACID原理** 

Redo/Undo机制比较简单，它们将所有对数据的更新操作都写到日志中。Redo log用来记录某数据块被修改后的值，可以用来恢复未写入 data file 的已成功事务更新的数据；Undo log是用来记录数据更新前的值，保证数据更新失败能够回滚。（ps  假如某个时刻数据库崩溃，在崩溃之前有事务A和事务B在执行，事务A已经提交，而事务B还未提交。当数据库重启进行 crash-recovery 时，就会通过Redo log将已经提交事务的更改写到数据文件，而还没有提交的就通过Undo log进行roll back。 

### MVCC

MVCC 可以看做是行锁的一个变种，在很多情况下 MVCC 可以避免加锁，因此开销更小，不同事务型存储引擎对于 MVCC 的实现各有不同。 MVCC 的实现是通过保存数据在某个时间点的快照来实现的。也就是说，不管执行多长时间，每个事务看到的数据都是一致的。根据事务的开始时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。这里简单介绍一下 InnoDB 的 MVCC。 InnoDB 的 MVCC 通过在每行记录后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存了行的过期时间，存储的不是实际的时间，而是版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号作对比。下面详细介绍一下在可重复读隔离级别下，MVCC 的具体操作。

- SELECT
  - InnoDB 会根据以下两个条件检查每条记录：
    - 只查找版本小于等于事务版本号的行
    - 只查找未定义删除时间或者删除时间大于事务版本号的行
- INSERT
  - InnoDB 为新插入的每一行保存当前的系统版本号作为行版本号
- DELETE
  - InnoDB 为删除的每一行保存当前的系统版本号作为行的删除版本号
- UPDATE
  - InnoDB 新增一条记录，保存当前系统版本号作为新增行的版本号
  - 在被删除记录的原始行，保存当前系统版本号作为被删除记录行的删除版本号

优点：

1. 因为有了两个隐藏列来记录数据的状态，所以大多数读操作都可以不加锁
2. 性能好，同时可以保证读取的数据是正确的

缺点：

1. 需要额外的空间记录每行的状态
2. 需要行状态的维护和检查



